// DO NOT EDIT; Code generated by keywordgen.
package keywords

import (
	"github.com/elliotcourant/pgoparser/quotes"
	"strings"
)

var (
	keywordMap = map[string]func(value string) Keyword{
		"AS":         NewASKeyword,
		"BY":         NewBYKeyword,
		"CONSTRAINT": NewCONSTRAINTKeyword,
		"CREATE":     NewCREATEKeyword,
		"CROSS":      NewCROSSKeyword,
		"DATABASE":   NewDATABASEKeyword,
		"DISTINCT":   NewDISTINCTKeyword,
		"FOREIGN":    NewFOREIGNKeyword,
		"FROM":       NewFROMKeyword,
		"GROUP":      NewGROUPKeyword,
		"HAVING":     NewHAVINGKeyword,
		"INDEX":      NewINDEXKeyword,
		"INNER":      NewINNERKeyword,
		"IS":         NewISKeyword,
		"JOIN":       NewJOINKeyword,
		"KEY":        NewKEYKeyword,
		"LEFT":       NewLEFTKeyword,
		"LIMIT":      NewLIMITKeyword,
		"NOT":        NewNOTKeyword,
		"NULL":       NewNULLKeyword,
		"OFFSET":     NewOFFSETKeyword,
		"OUTER":      NewOUTERKeyword,
		"PRIMARY":    NewPRIMARYKeyword,
		"SELECT":     NewSELECTKeyword,
		"TABLE":      NewTABLEKeyword,
		"UNIQUE":     NewUNIQUEKeyword,
		"USER":       NewUSERKeyword,
		"VIEW":       NewVIEWKeyword,
		"WHERE":      NewWHEREKeyword,
		"WITH":       NewWITHKeyword,
	}
)

var (
	_       Keyword = AS{}
	_AS_STR         = strings.ToUpper("AS")
)

func NewASKeyword(value string) Keyword {
	if strings.ToUpper(value) != _AS_STR {
		panic("cannot create keyword AS from " + value)
	}

	return AS{
		Value: value,
	}
}

// AS is a pgoparser keyword.
type AS struct {
	Value string
}

// Token implements the Token interface for AS.
func (keyword AS) Token() {}

// Word implements the Word interface for AS.
func (keyword AS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword AS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for AS.
func (keyword AS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword AS) String() string {
	return keyword.Value
}

var (
	_       Keyword = BY{}
	_BY_STR         = strings.ToUpper("BY")
)

func NewBYKeyword(value string) Keyword {
	if strings.ToUpper(value) != _BY_STR {
		panic("cannot create keyword BY from " + value)
	}

	return BY{
		Value: value,
	}
}

// BY is a pgoparser keyword.
type BY struct {
	Value string
}

// Token implements the Token interface for BY.
func (keyword BY) Token() {}

// Word implements the Word interface for BY.
func (keyword BY) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword BY) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for BY.
func (keyword BY) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword BY) String() string {
	return keyword.Value
}

var (
	_               Keyword = CONSTRAINT{}
	_CONSTRAINT_STR         = strings.ToUpper("CONSTRAINT")
)

func NewCONSTRAINTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _CONSTRAINT_STR {
		panic("cannot create keyword CONSTRAINT from " + value)
	}

	return CONSTRAINT{
		Value: value,
	}
}

// CONSTRAINT is a pgoparser keyword.
type CONSTRAINT struct {
	Value string
}

// Token implements the Token interface for CONSTRAINT.
func (keyword CONSTRAINT) Token() {}

// Word implements the Word interface for CONSTRAINT.
func (keyword CONSTRAINT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword CONSTRAINT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for CONSTRAINT.
func (keyword CONSTRAINT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword CONSTRAINT) String() string {
	return keyword.Value
}

var (
	_           Keyword = CREATE{}
	_CREATE_STR         = strings.ToUpper("CREATE")
)

func NewCREATEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _CREATE_STR {
		panic("cannot create keyword CREATE from " + value)
	}

	return CREATE{
		Value: value,
	}
}

// CREATE is a pgoparser keyword.
type CREATE struct {
	Value string
}

// Token implements the Token interface for CREATE.
func (keyword CREATE) Token() {}

// Word implements the Word interface for CREATE.
func (keyword CREATE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword CREATE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for CREATE.
func (keyword CREATE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword CREATE) String() string {
	return keyword.Value
}

var (
	_          Keyword = CROSS{}
	_CROSS_STR         = strings.ToUpper("CROSS")
)

func NewCROSSKeyword(value string) Keyword {
	if strings.ToUpper(value) != _CROSS_STR {
		panic("cannot create keyword CROSS from " + value)
	}

	return CROSS{
		Value: value,
	}
}

// CROSS is a pgoparser keyword.
type CROSS struct {
	Value string
}

// Token implements the Token interface for CROSS.
func (keyword CROSS) Token() {}

// Word implements the Word interface for CROSS.
func (keyword CROSS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword CROSS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for CROSS.
func (keyword CROSS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword CROSS) String() string {
	return keyword.Value
}

var (
	_             Keyword = DATABASE{}
	_DATABASE_STR         = strings.ToUpper("DATABASE")
)

func NewDATABASEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _DATABASE_STR {
		panic("cannot create keyword DATABASE from " + value)
	}

	return DATABASE{
		Value: value,
	}
}

// DATABASE is a pgoparser keyword.
type DATABASE struct {
	Value string
}

// Token implements the Token interface for DATABASE.
func (keyword DATABASE) Token() {}

// Word implements the Word interface for DATABASE.
func (keyword DATABASE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword DATABASE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for DATABASE.
func (keyword DATABASE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword DATABASE) String() string {
	return keyword.Value
}

var (
	_             Keyword = DISTINCT{}
	_DISTINCT_STR         = strings.ToUpper("DISTINCT")
)

func NewDISTINCTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _DISTINCT_STR {
		panic("cannot create keyword DISTINCT from " + value)
	}

	return DISTINCT{
		Value: value,
	}
}

// DISTINCT is a pgoparser keyword.
type DISTINCT struct {
	Value string
}

// Token implements the Token interface for DISTINCT.
func (keyword DISTINCT) Token() {}

// Word implements the Word interface for DISTINCT.
func (keyword DISTINCT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword DISTINCT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for DISTINCT.
func (keyword DISTINCT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword DISTINCT) String() string {
	return keyword.Value
}

var (
	_            Keyword = FOREIGN{}
	_FOREIGN_STR         = strings.ToUpper("FOREIGN")
)

func NewFOREIGNKeyword(value string) Keyword {
	if strings.ToUpper(value) != _FOREIGN_STR {
		panic("cannot create keyword FOREIGN from " + value)
	}

	return FOREIGN{
		Value: value,
	}
}

// FOREIGN is a pgoparser keyword.
type FOREIGN struct {
	Value string
}

// Token implements the Token interface for FOREIGN.
func (keyword FOREIGN) Token() {}

// Word implements the Word interface for FOREIGN.
func (keyword FOREIGN) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword FOREIGN) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for FOREIGN.
func (keyword FOREIGN) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword FOREIGN) String() string {
	return keyword.Value
}

var (
	_         Keyword = FROM{}
	_FROM_STR         = strings.ToUpper("FROM")
)

func NewFROMKeyword(value string) Keyword {
	if strings.ToUpper(value) != _FROM_STR {
		panic("cannot create keyword FROM from " + value)
	}

	return FROM{
		Value: value,
	}
}

// FROM is a pgoparser keyword.
type FROM struct {
	Value string
}

// Token implements the Token interface for FROM.
func (keyword FROM) Token() {}

// Word implements the Word interface for FROM.
func (keyword FROM) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword FROM) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for FROM.
func (keyword FROM) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword FROM) String() string {
	return keyword.Value
}

var (
	_          Keyword = GROUP{}
	_GROUP_STR         = strings.ToUpper("GROUP")
)

func NewGROUPKeyword(value string) Keyword {
	if strings.ToUpper(value) != _GROUP_STR {
		panic("cannot create keyword GROUP from " + value)
	}

	return GROUP{
		Value: value,
	}
}

// GROUP is a pgoparser keyword.
type GROUP struct {
	Value string
}

// Token implements the Token interface for GROUP.
func (keyword GROUP) Token() {}

// Word implements the Word interface for GROUP.
func (keyword GROUP) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword GROUP) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for GROUP.
func (keyword GROUP) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword GROUP) String() string {
	return keyword.Value
}

var (
	_           Keyword = HAVING{}
	_HAVING_STR         = strings.ToUpper("HAVING")
)

func NewHAVINGKeyword(value string) Keyword {
	if strings.ToUpper(value) != _HAVING_STR {
		panic("cannot create keyword HAVING from " + value)
	}

	return HAVING{
		Value: value,
	}
}

// HAVING is a pgoparser keyword.
type HAVING struct {
	Value string
}

// Token implements the Token interface for HAVING.
func (keyword HAVING) Token() {}

// Word implements the Word interface for HAVING.
func (keyword HAVING) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword HAVING) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for HAVING.
func (keyword HAVING) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword HAVING) String() string {
	return keyword.Value
}

var (
	_          Keyword = INDEX{}
	_INDEX_STR         = strings.ToUpper("INDEX")
)

func NewINDEXKeyword(value string) Keyword {
	if strings.ToUpper(value) != _INDEX_STR {
		panic("cannot create keyword INDEX from " + value)
	}

	return INDEX{
		Value: value,
	}
}

// INDEX is a pgoparser keyword.
type INDEX struct {
	Value string
}

// Token implements the Token interface for INDEX.
func (keyword INDEX) Token() {}

// Word implements the Word interface for INDEX.
func (keyword INDEX) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword INDEX) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for INDEX.
func (keyword INDEX) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword INDEX) String() string {
	return keyword.Value
}

var (
	_          Keyword = INNER{}
	_INNER_STR         = strings.ToUpper("INNER")
)

func NewINNERKeyword(value string) Keyword {
	if strings.ToUpper(value) != _INNER_STR {
		panic("cannot create keyword INNER from " + value)
	}

	return INNER{
		Value: value,
	}
}

// INNER is a pgoparser keyword.
type INNER struct {
	Value string
}

// Token implements the Token interface for INNER.
func (keyword INNER) Token() {}

// Word implements the Word interface for INNER.
func (keyword INNER) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword INNER) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for INNER.
func (keyword INNER) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword INNER) String() string {
	return keyword.Value
}

var (
	_       Keyword = IS{}
	_IS_STR         = strings.ToUpper("IS")
)

func NewISKeyword(value string) Keyword {
	if strings.ToUpper(value) != _IS_STR {
		panic("cannot create keyword IS from " + value)
	}

	return IS{
		Value: value,
	}
}

// IS is a pgoparser keyword.
type IS struct {
	Value string
}

// Token implements the Token interface for IS.
func (keyword IS) Token() {}

// Word implements the Word interface for IS.
func (keyword IS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword IS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for IS.
func (keyword IS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword IS) String() string {
	return keyword.Value
}

var (
	_         Keyword = JOIN{}
	_JOIN_STR         = strings.ToUpper("JOIN")
)

func NewJOINKeyword(value string) Keyword {
	if strings.ToUpper(value) != _JOIN_STR {
		panic("cannot create keyword JOIN from " + value)
	}

	return JOIN{
		Value: value,
	}
}

// JOIN is a pgoparser keyword.
type JOIN struct {
	Value string
}

// Token implements the Token interface for JOIN.
func (keyword JOIN) Token() {}

// Word implements the Word interface for JOIN.
func (keyword JOIN) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword JOIN) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for JOIN.
func (keyword JOIN) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword JOIN) String() string {
	return keyword.Value
}

var (
	_        Keyword = KEY{}
	_KEY_STR         = strings.ToUpper("KEY")
)

func NewKEYKeyword(value string) Keyword {
	if strings.ToUpper(value) != _KEY_STR {
		panic("cannot create keyword KEY from " + value)
	}

	return KEY{
		Value: value,
	}
}

// KEY is a pgoparser keyword.
type KEY struct {
	Value string
}

// Token implements the Token interface for KEY.
func (keyword KEY) Token() {}

// Word implements the Word interface for KEY.
func (keyword KEY) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword KEY) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for KEY.
func (keyword KEY) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword KEY) String() string {
	return keyword.Value
}

var (
	_         Keyword = LEFT{}
	_LEFT_STR         = strings.ToUpper("LEFT")
)

func NewLEFTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _LEFT_STR {
		panic("cannot create keyword LEFT from " + value)
	}

	return LEFT{
		Value: value,
	}
}

// LEFT is a pgoparser keyword.
type LEFT struct {
	Value string
}

// Token implements the Token interface for LEFT.
func (keyword LEFT) Token() {}

// Word implements the Word interface for LEFT.
func (keyword LEFT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword LEFT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for LEFT.
func (keyword LEFT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword LEFT) String() string {
	return keyword.Value
}

var (
	_          Keyword = LIMIT{}
	_LIMIT_STR         = strings.ToUpper("LIMIT")
)

func NewLIMITKeyword(value string) Keyword {
	if strings.ToUpper(value) != _LIMIT_STR {
		panic("cannot create keyword LIMIT from " + value)
	}

	return LIMIT{
		Value: value,
	}
}

// LIMIT is a pgoparser keyword.
type LIMIT struct {
	Value string
}

// Token implements the Token interface for LIMIT.
func (keyword LIMIT) Token() {}

// Word implements the Word interface for LIMIT.
func (keyword LIMIT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword LIMIT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for LIMIT.
func (keyword LIMIT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword LIMIT) String() string {
	return keyword.Value
}

var (
	_        Keyword = NOT{}
	_NOT_STR         = strings.ToUpper("NOT")
)

func NewNOTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _NOT_STR {
		panic("cannot create keyword NOT from " + value)
	}

	return NOT{
		Value: value,
	}
}

// NOT is a pgoparser keyword.
type NOT struct {
	Value string
}

// Token implements the Token interface for NOT.
func (keyword NOT) Token() {}

// Word implements the Word interface for NOT.
func (keyword NOT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword NOT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for NOT.
func (keyword NOT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword NOT) String() string {
	return keyword.Value
}

var (
	_         Keyword = NULL{}
	_NULL_STR         = strings.ToUpper("NULL")
)

func NewNULLKeyword(value string) Keyword {
	if strings.ToUpper(value) != _NULL_STR {
		panic("cannot create keyword NULL from " + value)
	}

	return NULL{
		Value: value,
	}
}

// NULL is a pgoparser keyword.
type NULL struct {
	Value string
}

// Token implements the Token interface for NULL.
func (keyword NULL) Token() {}

// Word implements the Word interface for NULL.
func (keyword NULL) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword NULL) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for NULL.
func (keyword NULL) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword NULL) String() string {
	return keyword.Value
}

var (
	_           Keyword = OFFSET{}
	_OFFSET_STR         = strings.ToUpper("OFFSET")
)

func NewOFFSETKeyword(value string) Keyword {
	if strings.ToUpper(value) != _OFFSET_STR {
		panic("cannot create keyword OFFSET from " + value)
	}

	return OFFSET{
		Value: value,
	}
}

// OFFSET is a pgoparser keyword.
type OFFSET struct {
	Value string
}

// Token implements the Token interface for OFFSET.
func (keyword OFFSET) Token() {}

// Word implements the Word interface for OFFSET.
func (keyword OFFSET) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword OFFSET) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for OFFSET.
func (keyword OFFSET) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword OFFSET) String() string {
	return keyword.Value
}

var (
	_          Keyword = OUTER{}
	_OUTER_STR         = strings.ToUpper("OUTER")
)

func NewOUTERKeyword(value string) Keyword {
	if strings.ToUpper(value) != _OUTER_STR {
		panic("cannot create keyword OUTER from " + value)
	}

	return OUTER{
		Value: value,
	}
}

// OUTER is a pgoparser keyword.
type OUTER struct {
	Value string
}

// Token implements the Token interface for OUTER.
func (keyword OUTER) Token() {}

// Word implements the Word interface for OUTER.
func (keyword OUTER) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword OUTER) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for OUTER.
func (keyword OUTER) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword OUTER) String() string {
	return keyword.Value
}

var (
	_            Keyword = PRIMARY{}
	_PRIMARY_STR         = strings.ToUpper("PRIMARY")
)

func NewPRIMARYKeyword(value string) Keyword {
	if strings.ToUpper(value) != _PRIMARY_STR {
		panic("cannot create keyword PRIMARY from " + value)
	}

	return PRIMARY{
		Value: value,
	}
}

// PRIMARY is a pgoparser keyword.
type PRIMARY struct {
	Value string
}

// Token implements the Token interface for PRIMARY.
func (keyword PRIMARY) Token() {}

// Word implements the Word interface for PRIMARY.
func (keyword PRIMARY) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword PRIMARY) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for PRIMARY.
func (keyword PRIMARY) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword PRIMARY) String() string {
	return keyword.Value
}

var (
	_           Keyword = SELECT{}
	_SELECT_STR         = strings.ToUpper("SELECT")
)

func NewSELECTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _SELECT_STR {
		panic("cannot create keyword SELECT from " + value)
	}

	return SELECT{
		Value: value,
	}
}

// SELECT is a pgoparser keyword.
type SELECT struct {
	Value string
}

// Token implements the Token interface for SELECT.
func (keyword SELECT) Token() {}

// Word implements the Word interface for SELECT.
func (keyword SELECT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword SELECT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for SELECT.
func (keyword SELECT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword SELECT) String() string {
	return keyword.Value
}

var (
	_          Keyword = TABLE{}
	_TABLE_STR         = strings.ToUpper("TABLE")
)

func NewTABLEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _TABLE_STR {
		panic("cannot create keyword TABLE from " + value)
	}

	return TABLE{
		Value: value,
	}
}

// TABLE is a pgoparser keyword.
type TABLE struct {
	Value string
}

// Token implements the Token interface for TABLE.
func (keyword TABLE) Token() {}

// Word implements the Word interface for TABLE.
func (keyword TABLE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword TABLE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for TABLE.
func (keyword TABLE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword TABLE) String() string {
	return keyword.Value
}

var (
	_           Keyword = UNIQUE{}
	_UNIQUE_STR         = strings.ToUpper("UNIQUE")
)

func NewUNIQUEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _UNIQUE_STR {
		panic("cannot create keyword UNIQUE from " + value)
	}

	return UNIQUE{
		Value: value,
	}
}

// UNIQUE is a pgoparser keyword.
type UNIQUE struct {
	Value string
}

// Token implements the Token interface for UNIQUE.
func (keyword UNIQUE) Token() {}

// Word implements the Word interface for UNIQUE.
func (keyword UNIQUE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword UNIQUE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for UNIQUE.
func (keyword UNIQUE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword UNIQUE) String() string {
	return keyword.Value
}

var (
	_         Keyword = USER{}
	_USER_STR         = strings.ToUpper("USER")
)

func NewUSERKeyword(value string) Keyword {
	if strings.ToUpper(value) != _USER_STR {
		panic("cannot create keyword USER from " + value)
	}

	return USER{
		Value: value,
	}
}

// USER is a pgoparser keyword.
type USER struct {
	Value string
}

// Token implements the Token interface for USER.
func (keyword USER) Token() {}

// Word implements the Word interface for USER.
func (keyword USER) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword USER) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for USER.
func (keyword USER) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword USER) String() string {
	return keyword.Value
}

var (
	_         Keyword = VIEW{}
	_VIEW_STR         = strings.ToUpper("VIEW")
)

func NewVIEWKeyword(value string) Keyword {
	if strings.ToUpper(value) != _VIEW_STR {
		panic("cannot create keyword VIEW from " + value)
	}

	return VIEW{
		Value: value,
	}
}

// VIEW is a pgoparser keyword.
type VIEW struct {
	Value string
}

// Token implements the Token interface for VIEW.
func (keyword VIEW) Token() {}

// Word implements the Word interface for VIEW.
func (keyword VIEW) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword VIEW) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for VIEW.
func (keyword VIEW) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword VIEW) String() string {
	return keyword.Value
}

var (
	_          Keyword = WHERE{}
	_WHERE_STR         = strings.ToUpper("WHERE")
)

func NewWHEREKeyword(value string) Keyword {
	if strings.ToUpper(value) != _WHERE_STR {
		panic("cannot create keyword WHERE from " + value)
	}

	return WHERE{
		Value: value,
	}
}

// WHERE is a pgoparser keyword.
type WHERE struct {
	Value string
}

// Token implements the Token interface for WHERE.
func (keyword WHERE) Token() {}

// Word implements the Word interface for WHERE.
func (keyword WHERE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword WHERE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for WHERE.
func (keyword WHERE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword WHERE) String() string {
	return keyword.Value
}

var (
	_         Keyword = WITH{}
	_WITH_STR         = strings.ToUpper("WITH")
)

func NewWITHKeyword(value string) Keyword {
	if strings.ToUpper(value) != _WITH_STR {
		panic("cannot create keyword WITH from " + value)
	}

	return WITH{
		Value: value,
	}
}

// WITH is a pgoparser keyword.
type WITH struct {
	Value string
}

// Token implements the Token interface for WITH.
func (keyword WITH) Token() {}

// Word implements the Word interface for WITH.
func (keyword WITH) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword WITH) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for WITH.
func (keyword WITH) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword WITH) String() string {
	return keyword.Value
}
