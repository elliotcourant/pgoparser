// DO NOT EDIT; Code generated by keywordgen.
package keywords

import (
	"github.com/elliotcourant/pgoparser/quotes"
	"strings"
)

var (
	keywordMap = map[string]func(value string) Keyword{
		"AS":         NewASKeyword,
		"BY":         NewBYKeyword,
		"CONSTRAINT": NewCONSTRAINTKeyword,
		"CREATE":     NewCREATEKeyword,
		"CROSS":      NewCROSSKeyword,
		"DATABASE":   NewDATABASEKeyword,
		"DISTINCT":   NewDISTINCTKeyword,
		"EXISTS":     NewEXISTSKeyword,
		"FOREIGN":    NewFOREIGNKeyword,
		"FROM":       NewFROMKeyword,
		"GROUP":      NewGROUPKeyword,
		"HAVING":     NewHAVINGKeyword,
		"IF":         NewIFKeyword,
		"INDEX":      NewINDEXKeyword,
		"INNER":      NewINNERKeyword,
		"IS":         NewISKeyword,
		"JOIN":       NewJOINKeyword,
		"KEY":        NewKEYKeyword,
		"LEFT":       NewLEFTKeyword,
		"LIMIT":      NewLIMITKeyword,
		"NOT":        NewNOTKeyword,
		"NULL":       NewNULLKeyword,
		"OFFSET":     NewOFFSETKeyword,
		"OUTER":      NewOUTERKeyword,
		"PRIMARY":    NewPRIMARYKeyword,
		"SCHEMA":     NewSCHEMAKeyword,
		"SELECT":     NewSELECTKeyword,
		"TABLE":      NewTABLEKeyword,
		"UNIQUE":     NewUNIQUEKeyword,
		"USER":       NewUSERKeyword,
		"VIEW":       NewVIEWKeyword,
		"WHERE":      NewWHEREKeyword,
		"WITH":       NewWITHKeyword,
	}
)

var (
	_       Keyword = AS{}
	_AS_STR         = strings.ToUpper("AS")
)

func NewASKeyword(value string) Keyword {
	if strings.ToUpper(value) != _AS_STR {
		panic("cannot create keyword AS from " + value)
	}

	return AS{}
}

// AS is a pgoparser keyword.
type AS struct{}

// Token implements the Token interface for AS.
func (keyword AS) Token() {}

// Word implements the Word interface for AS.
func (keyword AS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword AS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for AS.
func (keyword AS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword AS) String() string {
	return "AS"
}

var (
	_       Keyword = BY{}
	_BY_STR         = strings.ToUpper("BY")
)

func NewBYKeyword(value string) Keyword {
	if strings.ToUpper(value) != _BY_STR {
		panic("cannot create keyword BY from " + value)
	}

	return BY{}
}

// BY is a pgoparser keyword.
type BY struct{}

// Token implements the Token interface for BY.
func (keyword BY) Token() {}

// Word implements the Word interface for BY.
func (keyword BY) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword BY) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for BY.
func (keyword BY) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword BY) String() string {
	return "BY"
}

var (
	_               Keyword = CONSTRAINT{}
	_CONSTRAINT_STR         = strings.ToUpper("CONSTRAINT")
)

func NewCONSTRAINTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _CONSTRAINT_STR {
		panic("cannot create keyword CONSTRAINT from " + value)
	}

	return CONSTRAINT{}
}

// CONSTRAINT is a pgoparser keyword.
type CONSTRAINT struct{}

// Token implements the Token interface for CONSTRAINT.
func (keyword CONSTRAINT) Token() {}

// Word implements the Word interface for CONSTRAINT.
func (keyword CONSTRAINT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword CONSTRAINT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for CONSTRAINT.
func (keyword CONSTRAINT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword CONSTRAINT) String() string {
	return "CONSTRAINT"
}

var (
	_           Keyword = CREATE{}
	_CREATE_STR         = strings.ToUpper("CREATE")
)

func NewCREATEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _CREATE_STR {
		panic("cannot create keyword CREATE from " + value)
	}

	return CREATE{}
}

// CREATE is a pgoparser keyword.
type CREATE struct{}

// Token implements the Token interface for CREATE.
func (keyword CREATE) Token() {}

// Word implements the Word interface for CREATE.
func (keyword CREATE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword CREATE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for CREATE.
func (keyword CREATE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword CREATE) String() string {
	return "CREATE"
}

var (
	_          Keyword = CROSS{}
	_CROSS_STR         = strings.ToUpper("CROSS")
)

func NewCROSSKeyword(value string) Keyword {
	if strings.ToUpper(value) != _CROSS_STR {
		panic("cannot create keyword CROSS from " + value)
	}

	return CROSS{}
}

// CROSS is a pgoparser keyword.
type CROSS struct{}

// Token implements the Token interface for CROSS.
func (keyword CROSS) Token() {}

// Word implements the Word interface for CROSS.
func (keyword CROSS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword CROSS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for CROSS.
func (keyword CROSS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword CROSS) String() string {
	return "CROSS"
}

var (
	_             Keyword = DATABASE{}
	_DATABASE_STR         = strings.ToUpper("DATABASE")
)

func NewDATABASEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _DATABASE_STR {
		panic("cannot create keyword DATABASE from " + value)
	}

	return DATABASE{}
}

// DATABASE is a pgoparser keyword.
type DATABASE struct{}

// Token implements the Token interface for DATABASE.
func (keyword DATABASE) Token() {}

// Word implements the Word interface for DATABASE.
func (keyword DATABASE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword DATABASE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for DATABASE.
func (keyword DATABASE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword DATABASE) String() string {
	return "DATABASE"
}

var (
	_             Keyword = DISTINCT{}
	_DISTINCT_STR         = strings.ToUpper("DISTINCT")
)

func NewDISTINCTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _DISTINCT_STR {
		panic("cannot create keyword DISTINCT from " + value)
	}

	return DISTINCT{}
}

// DISTINCT is a pgoparser keyword.
type DISTINCT struct{}

// Token implements the Token interface for DISTINCT.
func (keyword DISTINCT) Token() {}

// Word implements the Word interface for DISTINCT.
func (keyword DISTINCT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword DISTINCT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for DISTINCT.
func (keyword DISTINCT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword DISTINCT) String() string {
	return "DISTINCT"
}

var (
	_           Keyword = EXISTS{}
	_EXISTS_STR         = strings.ToUpper("EXISTS")
)

func NewEXISTSKeyword(value string) Keyword {
	if strings.ToUpper(value) != _EXISTS_STR {
		panic("cannot create keyword EXISTS from " + value)
	}

	return EXISTS{}
}

// EXISTS is a pgoparser keyword.
type EXISTS struct{}

// Token implements the Token interface for EXISTS.
func (keyword EXISTS) Token() {}

// Word implements the Word interface for EXISTS.
func (keyword EXISTS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword EXISTS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for EXISTS.
func (keyword EXISTS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword EXISTS) String() string {
	return "EXISTS"
}

var (
	_            Keyword = FOREIGN{}
	_FOREIGN_STR         = strings.ToUpper("FOREIGN")
)

func NewFOREIGNKeyword(value string) Keyword {
	if strings.ToUpper(value) != _FOREIGN_STR {
		panic("cannot create keyword FOREIGN from " + value)
	}

	return FOREIGN{}
}

// FOREIGN is a pgoparser keyword.
type FOREIGN struct{}

// Token implements the Token interface for FOREIGN.
func (keyword FOREIGN) Token() {}

// Word implements the Word interface for FOREIGN.
func (keyword FOREIGN) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword FOREIGN) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for FOREIGN.
func (keyword FOREIGN) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword FOREIGN) String() string {
	return "FOREIGN"
}

var (
	_         Keyword = FROM{}
	_FROM_STR         = strings.ToUpper("FROM")
)

func NewFROMKeyword(value string) Keyword {
	if strings.ToUpper(value) != _FROM_STR {
		panic("cannot create keyword FROM from " + value)
	}

	return FROM{}
}

// FROM is a pgoparser keyword.
type FROM struct{}

// Token implements the Token interface for FROM.
func (keyword FROM) Token() {}

// Word implements the Word interface for FROM.
func (keyword FROM) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword FROM) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for FROM.
func (keyword FROM) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword FROM) String() string {
	return "FROM"
}

var (
	_          Keyword = GROUP{}
	_GROUP_STR         = strings.ToUpper("GROUP")
)

func NewGROUPKeyword(value string) Keyword {
	if strings.ToUpper(value) != _GROUP_STR {
		panic("cannot create keyword GROUP from " + value)
	}

	return GROUP{}
}

// GROUP is a pgoparser keyword.
type GROUP struct{}

// Token implements the Token interface for GROUP.
func (keyword GROUP) Token() {}

// Word implements the Word interface for GROUP.
func (keyword GROUP) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword GROUP) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for GROUP.
func (keyword GROUP) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword GROUP) String() string {
	return "GROUP"
}

var (
	_           Keyword = HAVING{}
	_HAVING_STR         = strings.ToUpper("HAVING")
)

func NewHAVINGKeyword(value string) Keyword {
	if strings.ToUpper(value) != _HAVING_STR {
		panic("cannot create keyword HAVING from " + value)
	}

	return HAVING{}
}

// HAVING is a pgoparser keyword.
type HAVING struct{}

// Token implements the Token interface for HAVING.
func (keyword HAVING) Token() {}

// Word implements the Word interface for HAVING.
func (keyword HAVING) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword HAVING) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for HAVING.
func (keyword HAVING) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword HAVING) String() string {
	return "HAVING"
}

var (
	_       Keyword = IF{}
	_IF_STR         = strings.ToUpper("IF")
)

func NewIFKeyword(value string) Keyword {
	if strings.ToUpper(value) != _IF_STR {
		panic("cannot create keyword IF from " + value)
	}

	return IF{}
}

// IF is a pgoparser keyword.
type IF struct{}

// Token implements the Token interface for IF.
func (keyword IF) Token() {}

// Word implements the Word interface for IF.
func (keyword IF) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword IF) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for IF.
func (keyword IF) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword IF) String() string {
	return "IF"
}

var (
	_          Keyword = INDEX{}
	_INDEX_STR         = strings.ToUpper("INDEX")
)

func NewINDEXKeyword(value string) Keyword {
	if strings.ToUpper(value) != _INDEX_STR {
		panic("cannot create keyword INDEX from " + value)
	}

	return INDEX{}
}

// INDEX is a pgoparser keyword.
type INDEX struct{}

// Token implements the Token interface for INDEX.
func (keyword INDEX) Token() {}

// Word implements the Word interface for INDEX.
func (keyword INDEX) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword INDEX) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for INDEX.
func (keyword INDEX) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword INDEX) String() string {
	return "INDEX"
}

var (
	_          Keyword = INNER{}
	_INNER_STR         = strings.ToUpper("INNER")
)

func NewINNERKeyword(value string) Keyword {
	if strings.ToUpper(value) != _INNER_STR {
		panic("cannot create keyword INNER from " + value)
	}

	return INNER{}
}

// INNER is a pgoparser keyword.
type INNER struct{}

// Token implements the Token interface for INNER.
func (keyword INNER) Token() {}

// Word implements the Word interface for INNER.
func (keyword INNER) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword INNER) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for INNER.
func (keyword INNER) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword INNER) String() string {
	return "INNER"
}

var (
	_       Keyword = IS{}
	_IS_STR         = strings.ToUpper("IS")
)

func NewISKeyword(value string) Keyword {
	if strings.ToUpper(value) != _IS_STR {
		panic("cannot create keyword IS from " + value)
	}

	return IS{}
}

// IS is a pgoparser keyword.
type IS struct{}

// Token implements the Token interface for IS.
func (keyword IS) Token() {}

// Word implements the Word interface for IS.
func (keyword IS) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword IS) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for IS.
func (keyword IS) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword IS) String() string {
	return "IS"
}

var (
	_         Keyword = JOIN{}
	_JOIN_STR         = strings.ToUpper("JOIN")
)

func NewJOINKeyword(value string) Keyword {
	if strings.ToUpper(value) != _JOIN_STR {
		panic("cannot create keyword JOIN from " + value)
	}

	return JOIN{}
}

// JOIN is a pgoparser keyword.
type JOIN struct{}

// Token implements the Token interface for JOIN.
func (keyword JOIN) Token() {}

// Word implements the Word interface for JOIN.
func (keyword JOIN) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword JOIN) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for JOIN.
func (keyword JOIN) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword JOIN) String() string {
	return "JOIN"
}

var (
	_        Keyword = KEY{}
	_KEY_STR         = strings.ToUpper("KEY")
)

func NewKEYKeyword(value string) Keyword {
	if strings.ToUpper(value) != _KEY_STR {
		panic("cannot create keyword KEY from " + value)
	}

	return KEY{}
}

// KEY is a pgoparser keyword.
type KEY struct{}

// Token implements the Token interface for KEY.
func (keyword KEY) Token() {}

// Word implements the Word interface for KEY.
func (keyword KEY) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword KEY) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for KEY.
func (keyword KEY) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword KEY) String() string {
	return "KEY"
}

var (
	_         Keyword = LEFT{}
	_LEFT_STR         = strings.ToUpper("LEFT")
)

func NewLEFTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _LEFT_STR {
		panic("cannot create keyword LEFT from " + value)
	}

	return LEFT{}
}

// LEFT is a pgoparser keyword.
type LEFT struct{}

// Token implements the Token interface for LEFT.
func (keyword LEFT) Token() {}

// Word implements the Word interface for LEFT.
func (keyword LEFT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword LEFT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for LEFT.
func (keyword LEFT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword LEFT) String() string {
	return "LEFT"
}

var (
	_          Keyword = LIMIT{}
	_LIMIT_STR         = strings.ToUpper("LIMIT")
)

func NewLIMITKeyword(value string) Keyword {
	if strings.ToUpper(value) != _LIMIT_STR {
		panic("cannot create keyword LIMIT from " + value)
	}

	return LIMIT{}
}

// LIMIT is a pgoparser keyword.
type LIMIT struct{}

// Token implements the Token interface for LIMIT.
func (keyword LIMIT) Token() {}

// Word implements the Word interface for LIMIT.
func (keyword LIMIT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword LIMIT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for LIMIT.
func (keyword LIMIT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword LIMIT) String() string {
	return "LIMIT"
}

var (
	_        Keyword = NOT{}
	_NOT_STR         = strings.ToUpper("NOT")
)

func NewNOTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _NOT_STR {
		panic("cannot create keyword NOT from " + value)
	}

	return NOT{}
}

// NOT is a pgoparser keyword.
type NOT struct{}

// Token implements the Token interface for NOT.
func (keyword NOT) Token() {}

// Word implements the Word interface for NOT.
func (keyword NOT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword NOT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for NOT.
func (keyword NOT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword NOT) String() string {
	return "NOT"
}

var (
	_         Keyword = NULL{}
	_NULL_STR         = strings.ToUpper("NULL")
)

func NewNULLKeyword(value string) Keyword {
	if strings.ToUpper(value) != _NULL_STR {
		panic("cannot create keyword NULL from " + value)
	}

	return NULL{}
}

// NULL is a pgoparser keyword.
type NULL struct{}

// Token implements the Token interface for NULL.
func (keyword NULL) Token() {}

// Word implements the Word interface for NULL.
func (keyword NULL) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword NULL) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for NULL.
func (keyword NULL) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword NULL) String() string {
	return "NULL"
}

var (
	_           Keyword = OFFSET{}
	_OFFSET_STR         = strings.ToUpper("OFFSET")
)

func NewOFFSETKeyword(value string) Keyword {
	if strings.ToUpper(value) != _OFFSET_STR {
		panic("cannot create keyword OFFSET from " + value)
	}

	return OFFSET{}
}

// OFFSET is a pgoparser keyword.
type OFFSET struct{}

// Token implements the Token interface for OFFSET.
func (keyword OFFSET) Token() {}

// Word implements the Word interface for OFFSET.
func (keyword OFFSET) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword OFFSET) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for OFFSET.
func (keyword OFFSET) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword OFFSET) String() string {
	return "OFFSET"
}

var (
	_          Keyword = OUTER{}
	_OUTER_STR         = strings.ToUpper("OUTER")
)

func NewOUTERKeyword(value string) Keyword {
	if strings.ToUpper(value) != _OUTER_STR {
		panic("cannot create keyword OUTER from " + value)
	}

	return OUTER{}
}

// OUTER is a pgoparser keyword.
type OUTER struct{}

// Token implements the Token interface for OUTER.
func (keyword OUTER) Token() {}

// Word implements the Word interface for OUTER.
func (keyword OUTER) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword OUTER) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for OUTER.
func (keyword OUTER) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword OUTER) String() string {
	return "OUTER"
}

var (
	_            Keyword = PRIMARY{}
	_PRIMARY_STR         = strings.ToUpper("PRIMARY")
)

func NewPRIMARYKeyword(value string) Keyword {
	if strings.ToUpper(value) != _PRIMARY_STR {
		panic("cannot create keyword PRIMARY from " + value)
	}

	return PRIMARY{}
}

// PRIMARY is a pgoparser keyword.
type PRIMARY struct{}

// Token implements the Token interface for PRIMARY.
func (keyword PRIMARY) Token() {}

// Word implements the Word interface for PRIMARY.
func (keyword PRIMARY) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword PRIMARY) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for PRIMARY.
func (keyword PRIMARY) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword PRIMARY) String() string {
	return "PRIMARY"
}

var (
	_           Keyword = SCHEMA{}
	_SCHEMA_STR         = strings.ToUpper("SCHEMA")
)

func NewSCHEMAKeyword(value string) Keyword {
	if strings.ToUpper(value) != _SCHEMA_STR {
		panic("cannot create keyword SCHEMA from " + value)
	}

	return SCHEMA{}
}

// SCHEMA is a pgoparser keyword.
type SCHEMA struct{}

// Token implements the Token interface for SCHEMA.
func (keyword SCHEMA) Token() {}

// Word implements the Word interface for SCHEMA.
func (keyword SCHEMA) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword SCHEMA) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for SCHEMA.
func (keyword SCHEMA) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword SCHEMA) String() string {
	return "SCHEMA"
}

var (
	_           Keyword = SELECT{}
	_SELECT_STR         = strings.ToUpper("SELECT")
)

func NewSELECTKeyword(value string) Keyword {
	if strings.ToUpper(value) != _SELECT_STR {
		panic("cannot create keyword SELECT from " + value)
	}

	return SELECT{}
}

// SELECT is a pgoparser keyword.
type SELECT struct{}

// Token implements the Token interface for SELECT.
func (keyword SELECT) Token() {}

// Word implements the Word interface for SELECT.
func (keyword SELECT) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword SELECT) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for SELECT.
func (keyword SELECT) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword SELECT) String() string {
	return "SELECT"
}

var (
	_          Keyword = TABLE{}
	_TABLE_STR         = strings.ToUpper("TABLE")
)

func NewTABLEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _TABLE_STR {
		panic("cannot create keyword TABLE from " + value)
	}

	return TABLE{}
}

// TABLE is a pgoparser keyword.
type TABLE struct{}

// Token implements the Token interface for TABLE.
func (keyword TABLE) Token() {}

// Word implements the Word interface for TABLE.
func (keyword TABLE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword TABLE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for TABLE.
func (keyword TABLE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword TABLE) String() string {
	return "TABLE"
}

var (
	_           Keyword = UNIQUE{}
	_UNIQUE_STR         = strings.ToUpper("UNIQUE")
)

func NewUNIQUEKeyword(value string) Keyword {
	if strings.ToUpper(value) != _UNIQUE_STR {
		panic("cannot create keyword UNIQUE from " + value)
	}

	return UNIQUE{}
}

// UNIQUE is a pgoparser keyword.
type UNIQUE struct{}

// Token implements the Token interface for UNIQUE.
func (keyword UNIQUE) Token() {}

// Word implements the Word interface for UNIQUE.
func (keyword UNIQUE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword UNIQUE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for UNIQUE.
func (keyword UNIQUE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword UNIQUE) String() string {
	return "UNIQUE"
}

var (
	_         Keyword = USER{}
	_USER_STR         = strings.ToUpper("USER")
)

func NewUSERKeyword(value string) Keyword {
	if strings.ToUpper(value) != _USER_STR {
		panic("cannot create keyword USER from " + value)
	}

	return USER{}
}

// USER is a pgoparser keyword.
type USER struct{}

// Token implements the Token interface for USER.
func (keyword USER) Token() {}

// Word implements the Word interface for USER.
func (keyword USER) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword USER) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for USER.
func (keyword USER) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword USER) String() string {
	return "USER"
}

var (
	_         Keyword = VIEW{}
	_VIEW_STR         = strings.ToUpper("VIEW")
)

func NewVIEWKeyword(value string) Keyword {
	if strings.ToUpper(value) != _VIEW_STR {
		panic("cannot create keyword VIEW from " + value)
	}

	return VIEW{}
}

// VIEW is a pgoparser keyword.
type VIEW struct{}

// Token implements the Token interface for VIEW.
func (keyword VIEW) Token() {}

// Word implements the Word interface for VIEW.
func (keyword VIEW) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword VIEW) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for VIEW.
func (keyword VIEW) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword VIEW) String() string {
	return "VIEW"
}

var (
	_          Keyword = WHERE{}
	_WHERE_STR         = strings.ToUpper("WHERE")
)

func NewWHEREKeyword(value string) Keyword {
	if strings.ToUpper(value) != _WHERE_STR {
		panic("cannot create keyword WHERE from " + value)
	}

	return WHERE{}
}

// WHERE is a pgoparser keyword.
type WHERE struct{}

// Token implements the Token interface for WHERE.
func (keyword WHERE) Token() {}

// Word implements the Word interface for WHERE.
func (keyword WHERE) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword WHERE) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for WHERE.
func (keyword WHERE) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword WHERE) String() string {
	return "WHERE"
}

var (
	_         Keyword = WITH{}
	_WITH_STR         = strings.ToUpper("WITH")
)

func NewWITHKeyword(value string) Keyword {
	if strings.ToUpper(value) != _WITH_STR {
		panic("cannot create keyword WITH from " + value)
	}

	return WITH{}
}

// WITH is a pgoparser keyword.
type WITH struct{}

// Token implements the Token interface for WITH.
func (keyword WITH) Token() {}

// Word implements the Word interface for WITH.
func (keyword WITH) Word() {}

// Quotes will always return quotes.None for a valid keyword.
func (keyword WITH) Quotes() quotes.Quotes {
	return quotes.None
}

// Keyword implements the Keyword interface for WITH.
func (keyword WITH) Keyword() {}

// String returns the actual input string representation of the word.
func (keyword WITH) String() string {
	return "WITH"
}
